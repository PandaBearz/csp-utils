'''
A LogEntry is a CSP violation Report wrapped in another JSON dictionary with a specific
set of keys that indicate, most importantly, the type of the report (whether it is a regular,
eval, or inline report), and a few other details, such as the date, IP address and user agent
string of the browser that sent the report:

    'csp-report': the Report object.
    'remote-addr': the IP address of the client that sent the report.
    'http-user-agent': the user agent identifier of the browser that sent the report.
    'timestamp-utc': the time (in UTC) when the report was received. Example: "2013-12-14 02:58:35.280001"
    'policy-type': the type of the violation (either "regular", "eval" or "inline"). These values are
                    generated by sending three different policies to browsers in parallel and using different
                    URIs for the report sink. See the documentation for the method LogEntry.generatePolicy(.)
                    or the log entry collection script csp-report-sink.cgi for details about these three policies.

LogEntryParser can be used to convert strings into LogEntry objects.

@author: Tobias Lauinger <toby@ccs.neu.edu>
'''

import collections
import json
from csp.reportjsonencoder import ReportJSONEncoder
from csp.report import ReportParser, Report
from csp.policy import Policy


class LogEntry(collections.Mapping):
    '''
    A LogEntry is an entry in the CSP violation report sink. It consists of a CSP Report plus
    a timestamp, the IP address of the browser, the user agent string, and the type of the
    violated policy header ('regular', 'eval', or 'inline').
    '''

    _invalid = None

    def __init__(self, dataDict):
        """
        Generates a new CSP LogEntry from the given data.
        
        'dataDict' is a dictionary with the field names of a log entry and the values MUST all be
        immutable.
        """
        self._hash = None
        self._str = None
        self._entryData = dict(dataDict)
    
    @staticmethod
    def INVALID():
        """
        Special static singleton LogEntry representing an invalid log entry (could not be parsed).
        """
        if LogEntry._invalid is None:
            LogEntry._invalid = LogEntry({})
        return LogEntry._invalid
        
    def generatePolicy(self):
        """
        Generates a new policy that allows exactly the kind of event that caused the CSP violation report
        in this log entry (but nothing more). This assumes that (1) the violation report contains a specific
        violated-directive field (it may not be 'default-src'), and (2) that the log entry contains the type
        of the violation report ('regular', 'eval' or 'inline'). If any inconsistent log entries/reports are used
        to generate policies, the policies themselves will be inconsistent. The result of this method is
        a Policy. It is Policy.INVALID() if (1) the violated directive is missing, Directive.INVALID() or
        'default-src', (2) if this log entry has none of the types 'regular', 'inline' or 'eval', (3) the
        'blocked-uri' is URI.INVALID() or URI.EMPTY() in the 'regular' case.
        
        The result is a basic Policy containing one whitelisted resource (corresponding to the violated directive). 
        In practice, it should not be used alone, but be combined with basic policies generated for other violations
        on the same web site. It should also be prepended with "default-src 'none'" to ensure that only the
        whitelisted resources are allowed. (The standard behaviour of CSP in absence of any default Directive is
        to assume "default-src *", which may not be the desired behaviour.)
        
        In particular, policies should be collected with CSP headers like these:
        
        Content-Security-Policy-Report-Only: default-src 'none'; script-src 'unsafe-eval' 'unsafe-inline'; object-src 'none'; style-src 'unsafe-inline'; img-src 'none'; media-src 'none'; frame-src 'none'; font-src 'none'; connect-src 'none'; report-uri /csp.cgi?type=regular
        Content-Security-Policy-Report-Only: default-src *; script-src * 'unsafe-inline'; style-src * 'unsafe-inline'; report-uri /csp.cgi?type=eval
        Content-Security-Policy-Report-Only: default-src *; script-src * 'unsafe-eval'; style-src *; report-uri /csp.cgi?type=inline
        
        The results should also be filtered to ensure that only reports sent by fully compatible browsers
        are taken into account.
        """
        if (self == LogEntry.INVALID()
            or 'policy-type' not in self 
            or 'csp-report' not in self):
            return Policy.INVALID()
        return self['csp-report'].generatePolicy(self['policy-type'])
        
    def __iter__(self):
        return iter(self._entryData)
    
    def __len__(self):
        return len(self._entryData)
    
    def __getitem__(self, key):
        return self._entryData[key]
    
    def __eq__(self, other):
        """
        Returns if this log entry is equal to another entry. This is implemented component-wise.
        """
        if type(other) != LogEntry:
            return False
        return self._entryData == other._entryData
    
    def __hash__(self):
        """
        Returns a hash value for this object that is guaranteed to be the same for two objects
        that are equal (the opposite is not necessarily true).
        """
        if self._hash is None:
            self._hash = reduce(lambda hashSoFar, pair: hashSoFar ^ hash(pair), self._entryData.iteritems(), 0)
        return self._hash
    
    def __repr__(self):
        """
        Returns a full representation of this LogEntry. Equivalent to __str__().
        """
        return str(self)
        
    def __str__(self):
        """
        Returns a JSON representation of this log entry with keys ordered alphabetically.
        """
        if self._str is None:
            if self == LogEntry.INVALID():
                self._str = "[invalid]"
            else:
                dat = self._entryData.copy()
                dat["csp-report"] = dat["csp-report"]._repData
                self._str = json.dumps(dat, sort_keys=True, cls=ReportJSONEncoder)
        return self._str
    

class LogEntryParser(object):
    """
    Pre-configured object that parses strings or JSON dictionaries into LogEntries.
    """
    
    def __init__(self, 
                 uriKeys=('blocked-uri', 'document-uri', 'referrer'),
                 directiveKeys=('violated-directive',),
                 policyKeys=("original-policy",),
                 keyNameReplacements={'document-url': 'document-uri'},
                 requiredKeys=('blocked-uri', 'violated-directive', 'document-uri'),
                 strict=True,
                 addSchemeToURIs=False,
                 defaultURIScheme="http",
                 addPortToURIs=False,
                 defaultURIPort=80,
                 schemePortMappings={'http': 80, 'https': 443, 'data': None, 'chrome-extension': None, 
                                     'safari-extension': None, 'chromenull': None, 'chromeinvoke': None,
                                     'chromeinvokeimmediate': None, 'mx': None, 'moz-icon': None,
                                     'about': None, 'view-source': None},
                 portSchemeMappings={80: 'http', 443: 'https', 8080: 'http'},
                 directiveTypeTranslations={"xhr-src": "connect-src"}, 
                 allowedDirectiveTypes=("base-uri", "child-src", "connect-src", "default-src",
                               "font-src", "form-action", "frame-ancestors", "frame-src",
                               "img-src", "media-src", "object-src", "script-src", "style-src"),
                 ignoredDirectiveTypes=("plugin-types", "referrer", "reflected-xss", "report-uri", "sandbox"),
                 expandDefaultSrc=False,
                 defaultSrcTypes=("child-src", "connect-src", "font-src", "img-src", "media-src",
                                  "object-src", "script-src", "style-src")):
        """
        Creates a new LogEntryParser object configured with the following parameters:
        
        'uriKeys': an iterable of key (entry) names of which the corresponding values, if present,
                            will be parsed and replaced with an URI object.
        'directiveKeys': an iterable of key (entry) names of which the corresponding values, if present,
                            will be parsed and replaced with a Directive object.
        'policyKeys': an iterable of key (entry) names of which the corresponding values, if present,
                            will be parsed and replaced with a Policy object.
        The 'uriKeys', 'directiveKeys', and 'policyKeys' lists are mutually exclusive (a key may appear
                            in at most one of these lists.)
        'keyNameReplacements': a dictionary of old key (entry) names mapped to the new name to be given
                            to them before any further parsing. This can be used to adjust to renamed 
                            fields in the violation reports generated by different browser versions.
        'requiredKeys': an iterable of key (entry) names that are mandatory and must appear in the report
                            with a valid value (if parsed, cannot be URI.INVALID()/Directive.INVALID()/
                            Policy.INVALID()). If this constraint is violated, the parsing result will be
                            Report.INVALID() (independent of the 'strict' setting). This restriction is 
                            applied after performing key name replacement.
        'strict': whether a parsing error of a child element should be ignored if it can be fixed (if
                            set to False, invalid children will be skipped), or if any parsing error
                            should cause the Report to become Report.INVALID() (if set to True).
        'addSchemeToURIs': [for parsed URIs] whether to add the scheme. (See URIParser for details.)
        'defaultURIScheme': [for parsed URIs] if the scheme should be added, the default scheme to be 
                            assumed if nothing can be inferred from the port. (See URIParser for details.)
        'addPortToURIs': [for parsed URIs] whether to add the port. (See URIParser for details.)
        'defaultURIPort': [for parsed URIs] if the port should be added, the default port to be assumed
                            if nothing can be inferred from the scheme. (See URIParser for details.)
        'schemePortMappings': [for parsed URIs and policy/directive parsing] A map from scheme names to the 
                            corresponding default port, or None if the scheme does not use ports. Any scheme
                            that may appear inside an URI, source expression, directive or policy should be
                            listed. (See URIParser and SourceExpressionParser for details.)
        'portSchemeMappings': [for parsed URIs] A map from port numbers to scheme names (only for "real" ports).
                            See URIParser for details.
        'directiveTypeTranslations': [for parsed directives and policies] A map from the old directive name to
                            the new name to be used. (See DirectiveParser for details.)
        'allowedDirectiveTypes': [for parsed directives and policies] a list of directive types that are allowed.
                            (See DirectiveParser or PolicyParser for details.)
        'ignoredDirectiveTypes': [for parsed policies] a list of directive types that are ignored when parsing
                            policies. (See PolicyParser for details.)
        'expandDefaultSrc': [for parsed policies] if set to True, each "default-src" directive in a parsed policy
                            will be expanded to the corresponding elementary directive types, if not yet present.
                            (See PolicyParser for details.)
        'defaultSrcTypes': [for parsed policies] when "default-src" is expanded, the elementary directive types
                            that will be added to replace the default policy. (See PolicyParser for details.)
        """
        self._strict = strict
        self._reportParser = ReportParser(uriKeys, directiveKeys, policyKeys, 
                                          keyNameReplacements, requiredKeys, strict, addSchemeToURIs, 
                                          defaultURIScheme, addPortToURIs, defaultURIPort, schemePortMappings, 
                                          portSchemeMappings, directiveTypeTranslations, allowedDirectiveTypes, 
                                          ignoredDirectiveTypes, expandDefaultSrc, defaultSrcTypes)
            
    def parseString(self, stringLogEntry):
        """
        Parses the given 'stringLogEntry' according to the parameters set in the constructor of this LogEntryParser 
        and returns a LogEntry object. 'stringLogEntry' is expected to be a JSON-serialised map. If 'stringLogEntry' 
        cannot be parsed because it is syntactically invalid (or empty), LogEntry.INVALID() will be returned.
        """
        try:
            jsonDict = json.loads(stringLogEntry)
            return self.parseJsonDict(jsonDict)
        except ValueError:
            return LogEntry.INVALID()
    
    def parseJsonDict(self, jsonLogEntry):
        """
        Parses the given 'jsonLogEntry' according to the parameters set in the constructor of this LogEntryParser 
        and returns a LogEntry object. 'jsonLogEntry' is expected to be a Python dict object. If 'jsonLogEntry' 
        cannot be parsed because it is syntactically invalid (or empty), LogEntry.INVALID() will be returned.
        """
        
        # TODO: could also parse the timestamp string etc.
        if "csp-report" in jsonLogEntry:
            jsonLogEntry["csp-report"] = self._reportParser.parseJsonDict(jsonLogEntry["csp-report"])
            if self._strict and jsonLogEntry["csp-report"] == Report.INVALID():
                return LogEntry.INVALID()
            else:
                return LogEntry(jsonLogEntry)
        else:
            return LogEntry.INVALID()
    
